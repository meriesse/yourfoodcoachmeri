{"ast":null,"code":"import * as Url from 'url';\nimport { errorCode } from './errors';\nconst MIN_DOMAIN_SEGMENTS = 2;\nconst NON_ASCII_RX = /[^\\x00-\\x7f]/;\nconst DOMAIN_CONTROL_RX = /[\\x00-\\x20@\\:\\/\\\\#!\\$&\\'\\(\\)\\*\\+,;=\\?]/; // Control + space + separators\nconst TLD_SEGMENT_RX = /^[a-zA-Z](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/;\nconst DOMAIN_SEGMENT_RX = /^[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/;\nconst URL_IMPL = Url.URL || URL; // $lab:coverage:ignore$\nfunction isTldsAllow(tlds) {\n  return !!tlds.allow;\n}\n/**\n * Analyzes a string to verify it is a valid domain name.\n *\n * @param domain - the domain name to validate.\n * @param options - optional settings.\n *\n * @return - undefined when valid, otherwise an object with single error key with a string message value.\n */\nexport function analyzeDomain(domain, options = {}) {\n  if (!domain) {\n    // Catch null / undefined\n    return errorCode('DOMAIN_NON_EMPTY_STRING');\n  }\n  if (typeof domain !== 'string') {\n    throw new Error('Invalid input: domain must be a string');\n  }\n  if (domain.length > 256) {\n    return errorCode('DOMAIN_TOO_LONG');\n  }\n  const ascii = !NON_ASCII_RX.test(domain);\n  if (!ascii) {\n    if (options.allowUnicode === false) {\n      // Defaults to true\n      return errorCode('DOMAIN_INVALID_UNICODE_CHARS');\n    }\n    domain = domain.normalize('NFC');\n  }\n  if (DOMAIN_CONTROL_RX.test(domain)) {\n    return errorCode('DOMAIN_INVALID_CHARS');\n  }\n  domain = punycode(domain);\n  // https://tools.ietf.org/html/rfc1035 section 2.3.1\n  if (options.allowFullyQualified && domain[domain.length - 1] === '.') {\n    domain = domain.slice(0, -1);\n  }\n  const minDomainSegments = options.minDomainSegments || MIN_DOMAIN_SEGMENTS;\n  const segments = domain.split('.');\n  if (segments.length < minDomainSegments) {\n    return errorCode('DOMAIN_SEGMENTS_COUNT');\n  }\n  if (options.maxDomainSegments) {\n    if (segments.length > options.maxDomainSegments) {\n      return errorCode('DOMAIN_SEGMENTS_COUNT_MAX');\n    }\n  }\n  const tlds = options.tlds;\n  if (tlds) {\n    const tld = segments[segments.length - 1].toLowerCase();\n    if (isTldsAllow(tlds)) {\n      if (!tlds.allow.has(tld)) {\n        return errorCode('DOMAIN_FORBIDDEN_TLDS');\n      }\n    } else if (tlds.deny.has(tld)) {\n      return errorCode('DOMAIN_FORBIDDEN_TLDS');\n    }\n  }\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    if (!segment.length) {\n      return errorCode('DOMAIN_EMPTY_SEGMENT');\n    }\n    if (segment.length > 63) {\n      return errorCode('DOMAIN_LONG_SEGMENT');\n    }\n    if (i < segments.length - 1) {\n      if (!DOMAIN_SEGMENT_RX.test(segment)) {\n        return errorCode('DOMAIN_INVALID_CHARS');\n      }\n    } else {\n      if (!TLD_SEGMENT_RX.test(segment)) {\n        return errorCode('DOMAIN_INVALID_TLDS_CHARS');\n      }\n    }\n  }\n  return null;\n}\n/**\n * Analyzes a string to verify it is a valid domain name.\n *\n * @param domain - the domain name to validate.\n * @param options - optional settings.\n *\n * @return - true when valid, otherwise false.\n */\nexport function isDomainValid(domain, options) {\n  return !analyzeDomain(domain, options);\n}\nfunction punycode(domain) {\n  if (domain.includes('%')) {\n    domain = domain.replace(/%/g, '%25');\n  }\n  try {\n    return new URL_IMPL(`http://${domain}`).host;\n  } catch (err) {\n    return domain;\n  }\n}\nexport function validateDomainOptions(options) {\n  if (!options) {\n    return;\n  }\n  if (typeof options.tlds !== 'object') {\n    throw new Error('Invalid options: tlds must be a boolean or an object');\n  }\n  if (isTldsAllow(options.tlds)) {\n    if (options.tlds.allow instanceof Set === false) {\n      throw new Error('Invalid options: tlds.allow must be a Set object or true');\n    }\n    if (options.tlds.deny) {\n      throw new Error('Invalid options: cannot specify both tlds.allow and tlds.deny lists');\n    }\n  } else {\n    if (options.tlds.deny instanceof Set === false) {\n      throw new Error('Invalid options: tlds.deny must be a Set object');\n    }\n  }\n}","map":{"version":3,"names":["Url","errorCode","MIN_DOMAIN_SEGMENTS","NON_ASCII_RX","DOMAIN_CONTROL_RX","TLD_SEGMENT_RX","DOMAIN_SEGMENT_RX","URL_IMPL","URL","isTldsAllow","tlds","allow","analyzeDomain","domain","options","Error","length","ascii","test","allowUnicode","normalize","punycode","allowFullyQualified","slice","minDomainSegments","segments","split","maxDomainSegments","tld","toLowerCase","has","deny","i","segment","isDomainValid","includes","replace","host","err","validateDomainOptions","Set"],"sources":["../src/domain.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}