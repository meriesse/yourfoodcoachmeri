{"ast":null,"code":"import * as Util from 'util';\nimport { analyzeDomain } from './domain';\nimport { errorCode } from './errors';\nconst NON_ASCII_RX = /[^\\x00-\\x7f]/;\nconst ENCODER_IMPL = new (Util.TextEncoder || TextEncoder)(); // $lab:coverage:ignore$\n/**\n * Analyzes a string to verify it is a valid email address.\n *\n * @param email - the email address to validate.\n * @param options - optional settings.\n *\n * @return - undefined when valid, otherwise an object with single error key with a string message value.\n */\nexport function analyzeEmail(email, options) {\n  return validateEmail(email, options);\n}\n/**\n * Analyzes a string to verify it is a valid email address.\n *\n * @param email - the email address to validate.\n * @param options - optional settings.\n *\n * @return - true when valid, otherwise false.\n */\nexport function isEmailValid(email, options) {\n  return !validateEmail(email, options);\n}\nfunction validateEmail(email, options = {}) {\n  if (typeof email !== 'string') {\n    throw new Error('Invalid input: email must be a string');\n  }\n  if (!email) {\n    return errorCode('EMPTY_STRING');\n  }\n  // Unicode\n  const ascii = !NON_ASCII_RX.test(email);\n  if (!ascii) {\n    if (options.allowUnicode === false) {\n      // Defaults to true\n      return errorCode('FORBIDDEN_UNICODE');\n    }\n    email = email.normalize('NFC');\n  }\n  // Basic structure\n  const parts = email.split('@');\n  if (parts.length !== 2) {\n    return parts.length > 2 ? errorCode('MULTIPLE_AT_CHAR') : errorCode('MISSING_AT_CHAR');\n  }\n  const [local, domain] = parts;\n  if (!local) {\n    return errorCode('EMPTY_LOCAL');\n  }\n  if (!options.ignoreLength) {\n    if (email.length > 254) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n      return errorCode('ADDRESS_TOO_LONG');\n    }\n    if (ENCODER_IMPL.encode(local).length > 64) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1\n      return errorCode('LOCAL_TOO_LONG');\n    }\n  }\n  // Validate parts\n  return validateLocal(local, ascii) || analyzeDomain(domain, options);\n}\nfunction validateLocal(local, ascii) {\n  const segments = local.split('.');\n  for (const segment of segments) {\n    if (!segment.length) {\n      return errorCode('EMPTY_LOCAL_SEGMENT');\n    }\n    if (ascii) {\n      if (!ATEXT_RX.test(segment)) {\n        return errorCode('INVALID_LOCAL_CHARS');\n      }\n      continue;\n    }\n    for (const char of segment) {\n      if (ATEXT_RX.test(char)) {\n        continue;\n      }\n      const binary = toBinary(char);\n      if (!ATOM_RX.test(binary)) {\n        return errorCode('INVALID_LOCAL_CHARS');\n      }\n    }\n  }\n  return null;\n}\nfunction toBinary(char) {\n  return Array.from(ENCODER_IMPL.encode(char)).map(v => String.fromCharCode(v)).join('');\n}\n/*\n    From RFC 5321:\n\n        Mailbox         =   Local-part \"@\" ( Domain / address-literal )\n\n        Local-part      =   Dot-string / Quoted-string\n        Dot-string      =   Atom *(\".\"  Atom)\n        Atom            =   1*atext\n        atext           =   ALPHA / DIGIT / \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \"/\" / \"=\" / \"?\" / \"^\" / \"_\" / \"`\" / \"{\" / \"|\" / \"}\" / \"~\"\n\n        Domain          =   sub-domain *(\".\" sub-domain)\n        sub-domain      =   Let-dig [Ldh-str]\n        Let-dig         =   ALPHA / DIGIT\n        Ldh-str         =   *( ALPHA / DIGIT / \"-\" ) Let-dig\n\n        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z\n        DIGIT           =   %x30-39                  ; 0-9\n\n    From RFC 6531:\n\n        sub-domain      =/  U-label\n        atext           =/  UTF8-non-ascii\n\n        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4\n\n        UTF8-2          =   %xC2-DF UTF8-tail\n        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /\n                            %xE1-EC 2( UTF8-tail ) /\n                            %xED %x80-9F UTF8-tail /\n                            %xEE-EF 2( UTF8-tail )\n        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /\n                            %xF1-F3 3( UTF8-tail ) /\n                            %xF4 %x80-8F 2( UTF8-tail )\n\n        UTF8-tail       =   %x80-BF\n\n    Note: The following are not supported:\n\n        RFC 5321: address-literal, Quoted-string\n        RFC 5322: obs-*, CFWS\n*/\nconst ATEXT_RX = /^[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+$/; // _ included in \\w\nconst ATOM_RX = new RegExp([\n//  %xC2-DF UTF8-tail\n'(?:[\\\\xc2-\\\\xdf][\\\\x80-\\\\xbf])',\n//  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )\n'(?:\\\\xe0[\\\\xa0-\\\\xbf][\\\\x80-\\\\xbf])|(?:[\\\\xe1-\\\\xec][\\\\x80-\\\\xbf]{2})|(?:\\\\xed[\\\\x80-\\\\x9f][\\\\x80-\\\\xbf])|(?:[\\\\xee-\\\\xef][\\\\x80-\\\\xbf]{2})',\n//  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )\n'(?:\\\\xf0[\\\\x90-\\\\xbf][\\\\x80-\\\\xbf]{2})|(?:[\\\\xf1-\\\\xf3][\\\\x80-\\\\xbf]{3})|(?:\\\\xf4[\\\\x80-\\\\x8f][\\\\x80-\\\\xbf]{2})'].join('|'));","map":{"version":3,"names":["Util","analyzeDomain","errorCode","NON_ASCII_RX","ENCODER_IMPL","TextEncoder","analyzeEmail","email","options","validateEmail","isEmailValid","Error","ascii","test","allowUnicode","normalize","parts","split","length","local","domain","ignoreLength","encode","validateLocal","segments","segment","ATEXT_RX","char","binary","toBinary","ATOM_RX","Array","from","map","v","String","fromCharCode","join","RegExp"],"sources":["../src/email.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}